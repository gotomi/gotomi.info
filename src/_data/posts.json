[{"data":{"title":"Evolution of web performance culture","author":["jerzy.jelinek"],"tags":["tech","webperf","frontend","performance","perfmatters","javascript"]},"content":"<p>The main goal of boosting website performance is to improve the user experience. In theory,\na satisfied customer is more likely to use a particular company’s services, which is then reflected in business results.\nHowever, from my own experience I can say that not every change can be easily converted into money.\nI would like to tell you how to reconcile these two worlds, how to convince the business that the benefits of\nbetter performance are a long-term investment, and how to streamline the development process during the design or code writing process.</p>\n<!--more-->\n<p>Web performance is a challenging and complex subject. It involves working at the intersection of content management,\nfrontend, backend and the network layer. Rarely does a single change make a dramatic difference in performance,\nonly the cumulative effort of small improvements in each of these areas produces noticeable results.</p>\n<p>As the team responsible for the performance of Allegro, we are responsible for implementing various optimizations,\nbut most of all we show other teams which modifications in their projects will positively affect the performance\nof the whole site. Our duty is to create the friendliest, performance-supporting work environment for developers\nand help non-technical people to understand the idea behind it.</p>\n<p>We would like to illustrate by our example how this can be achieved.</p>\n<h2>Stage One — Measuring The Web Performance</h2>\n<p>At Allegro, we want to know if and how a given functionality affects the user as well as our business metrics.\nIn order to prove our hypothesis about performance impact we had to prepare a whole mechanism that allows us\nto track and analyze performance changes. I described it in greater detail in my first article titled\n<a href=\"/2021/06/measuring-web-performance.html\">Measuring The Web Performance</a>.</p>\n<p>Only then we could start optimizing our pages. Our actions brought the expected effect — we made progress,\nbut the pace was not sufficient. We lacked the support of business people, who would see profit in all of this.</p>\n<h2>Stage Two — Make it clear that performance is important</h2>\n<p>We have gone to great lengths to make the entire organization realize that the gains from web performance are long-term and important overall.</p>\n<p>Everyone subconsciously knows that a faster site improves user experience. The earlier users are able to see a page and use it,\nthe more often they are likely to do so and return. However, we had a problem proving that it truly makes our company earn more,\nin the end this is what every business is about.</p>\n<p>The first milestone turned out to be a test conducted together with the SEO team. It was an A/B test,\nwhere some users got an optimized offers list page that was loading faster, and the rest got the original page.\nIt turned out that all examined pages were added to Google cache (previously there were only a few of them),\nthe number of clicks, average ranking position and number of views increased from a few to several percent\nand the expected business profit from such a change was at 13% of the current GMV originating from organic traffic.\nAlthough being only a proof of concept, this experiment turned out to be an enabler for our next steps.\nIt helped us understand better what we were aiming for.</p>\n<p>This experiment has opened the way for us to make more optimizations, it also provided us with a solid argument\nthat convinced other product teams. However, we still felt unsatisfied — if performance affects\nGMV indirectly through SEO then are we able to prove a direct correlation as well? We had plenty of data,\nbut we lacked the analytical expertise to process it, therefore, we asked our business analysts to help us.\nBased on historical performance* and business data, they were able to confirm the impact on business metrics!</p>\n<blockquote>\n<p>Each 100ms slowdown of First Input Delay results in an average drop in GMV of 3%.<br>\nEach 100ms slowdown of First Contentful Paint results in an average drop in GMV of 1.5%.<br>\nEach 100ms slowdown of Largest Contentful Paint results in an average drop in GMV of 0.5%.</p>\n</blockquote>\n<p>*The data comes from our real user measurements, not from synthetic tests.</p>\n<h2>Stage Three — Support for both business and developers</h2>\n<p>After confirming our hypothesis, we had to implement a number of measures to ensure that web performance\nis taken into consideration throughout the entire process of delivery for all functionalities.</p>\n<h3>Teaching</h3>\n<p>One of the main tasks of my team is to prepare the awareness campaign of our colleagues.\nTherefore, we periodically conduct two types of training:</p>\n<ul>\n<li>For engineers, where we focus on the technical part including how to use the available tools to write optimal code.</li>\n<li>For other employees (especially Product Managers), where we explain why performance is important and what benefits it brings.</li>\n</ul>\n<p>We assume that knowledge should be shared, that is why we describe each interesting case, experiment or bug fix on our internal blog.\nThanks to that we mitigate the risk that bad patterns will be repeated in the future.</p>\n<p>However, the best way to learn is to work with us directly, so we encourage everyone to visit us as part of the\n<a href=\"/2019/09/team-tourism-at-allegro.html\">team tourism</a> initiative.</p>\n<h3>Supporting technical teams</h3>\n<p>In our team we believe that we should automate every task possible. We want our tools to support\nthe work of our engineers, so that they don’t have to remember to run performance tests,\ncheck the size of the resulting files, etc. That is why we have prepared several checks that apply to components development\nin our <a href=\"/2016/03/Managing-Frontend-in-the-microservices-architecture.html\">Micro Frontends architecture</a>.</p>\n<h4>Automatic page scanner</h4>\n<p>That’s where the whole automation story started. To detect problems with assets we had to check each page manually.\nThis was neither convenient nor scalable, so we created our first bot, which used PageSpeed Insights to check if:</p>\n<ul>\n<li>assets are cached long enough,</li>\n<li>their sizes on the page are appropriate,</li>\n<li>there are any assets which are not minified,</li>\n<li>images are in the right format and size,</li>\n<li>some images should be loaded lazily.</li>\n</ul>\n<p>After detecting problems, we checked the owners of the asset or part of the page and notified them on Slack.</p>\n<p><img src=\"/img/articles/2021-09-23-evolution-of-web-performance-culture/brylant-bot.png\" alt=\"Brylant Bot\" title=\"Brylant Bot\"></p>\n<h4>Automatic comments in pull requests</h4>\n<p>Two comments are generated while building the component. The first one presents a comparison of assets size\nwith the target branch and the estimated cost of the change.</p>\n<p><img src=\"/img/articles/2021-09-23-evolution-of-web-performance-culture/gh-sizes.png\" alt=\"Asset size comparison\" title=\"Asset size comparison\"></p>\n<p>If the size exceeds the declared threshold, our entire team is automatically added as reviewers to the pull request.</p>\n<p>Additionally, to detect the culprit faster, a\n<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">Webpack Bundle Analyzer</a> report is generated.</p>\n<p>In the second one, Lighthouse reports for target and feature branches are compared in order to catch performance metrics’ regressions at this early stage.\nEach component has a list of predefined presets (input data) and a server that displays them.\nThis functionality is used for: development, visual regression, snapshot and performance testing.\nLighthouse report is generated for one or more predefined states every time the component is built.</p>\n<p><img src=\"/img/articles/2021-09-23-evolution-of-web-performance-culture/lighthouse-report.png\" alt=\"Lighthouse report\" title=\"Lighthouse report\"></p>\n<h4>Automatic notifications</h4>\n<p>My team is notified on Slack every time a new dependency is added to any of the components.\nWe want to make sure that the libraries used are optimal and have no better (smaller, faster) replacements.</p>\n<p><img src=\"/img/articles/2021-09-23-evolution-of-web-performance-culture/bot-deps.png\" alt=\"Dependencies notification\" title=\"Dependencies notification\"></p>\n<p>We get similar notifications when assets size changes by at least 5% compared to the target branch.\nWe want to make sure that, for example, treeshaking hasn’t broken down or some other change affecting the size has not occurred.</p>\n<p><img src=\"/img/articles/2021-09-23-evolution-of-web-performance-culture/bot-sizes.png\" alt=\"Size notification\" title=\"Size notification\"></p>\n<h4>ESlint</h4>\n<p>We use it not only for formatting but also for finding violations in our code using custom rules.\nWe have created several rules to support engineers in their daily work. You can read about a sample implementation\nin the post “<a href=\"/2020/08/using-eslint.html\">Using ESLint to improve your app’s performance</a>” on our blog.</p>\n<h4>Analyses</h4>\n<p>We get requests from other teams to analyze their components or sites. Sometimes they lack the time budget\nfor such analysis, but would like to know what to improve.</p>\n<h3>Research and development</h3>\n<p>Keep in mind that working on web performance is a continuous work. Every now and then new solutions,\nwhich may have a positive impact on the loading speed, appear on the market. Therefore, together with our team,\nwe run a series of tests to see if it makes sense to adopt a given solution.</p>\n<h3>Appreciation culture</h3>\n<p>We believe that the carrot is better than the stick, so we praise other teams for the achievements\nrelated to improving performance. Some time ago we used to write it down in the form of a newsletter,\nnow we talk about it during our sprint summaries.</p>\n<h2>Summary</h2>\n<p>We are constantly working on data collection, monitoring, awareness raising, optimization and research,\nwhich leads to a situation where more and more managers come to us for consultation.\nThey know that performance is important and needs to be taken care of. Allegro is constantly evolving,\nnew content and features are being created, without working on performance the site will slow down.\nHowever, we already have a whole arsenal of capabilities to help us deal with this.\nWe are no longer fighting alone as the Webperf team, but as an entire organization.</p>\n","excerpt":"<p>The main goal of boosting website performance is to improve the user experience. In theory,\na satisfied customer is more likely to use a particular company’s services, which is then reflected in business results.\nHowever, from my own experience I can say that not every change can be easily converted into money.\nI would like to tell you how to reconcile these two worlds, how to convince the business that the benefits of\nbetter performance are a long-term investment, and how to streamline the development process during the design or code writing process.</p>\n","date":"2021-09-23T00:00:00.000Z","year":"2021","month":"09","day":"23","slug":"2021-09-evolution-of-web-performance-culture","author":[{"author":"jerzy.jelinek","name":"Jerzy Jelinek","bio":"Webperf Team member. Performance enthusiast. Short sentences lover.","twitter":"jerzyjelinek"}]},{"data":{"title":"CSS Architecture and Performance in Micro Frontends","author":["mateusz.krzeszowiak"],"tags":["tech","webperf","frontend","performance","perfmatters","css"]},"content":"<p>It’s been over 5 years since the introduction of the <a href=\"https://blog.allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html\">article describing the ongoing transformation of Allegro’s frontend architecture</a> — an approach that was later formalized by the industry under the name of Micro Frontends. I think that after all this time we can safely say that this direction was correct and remained almost entirely unchanged in relation to the original idea. Still, some of the challenges foreseen in the publication soon became the reality. In this article I would like to focus on the CSS part of the whole adventure to tell you about how we manage consistency and frontend performance across over half a thousand components, and what it took us to get to where we stand today.</p>\n<!--more-->\n<h3>New Approach — New Challenges</h3>\n<p>Handling all the dependencies, libraries and visual compatibility when the entire website resides in a single repository is a challenge by itself. The level of difficulty increases even more, when there are hundreds of said repositories, each managed by a different team and tooling. When in such situation, one of the things that quickly become apparent is the need for some kind of guidelines around the look of various aspects of components being developed like color scheme, spacing, fonts etc. — those are exactly the reasons why the Metrum Design System came to life.</p>\n<p><img src=\"/img/articles/2021-07-29-css-architecture-and-performance-of-micro-frontends/metrum-design-system.jpg\" alt=\"Metrum Design System\" title=\"Metrum Design System\"></p>\n<p>In its initial form — apart from visual examples and design resources — Metrum was providing reusable PostCSS mixins that every developer could install via separate npm packages and include in the component they were working on.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&#x27;node_modules/@metrum/button/css/mixins.css&#x27;</span>;\n\n<span class=\"hljs-selector-class\">.button</span> {\n    <span class=\"hljs-keyword\">@mixin</span> m-button;\n    <span class=\"hljs-attribute\">background-color</span>: black;\n}\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;button&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<p>If we try to evaluate that approach we could come up with following pros and cons:</p>\n<p><strong>Pros</strong></p>\n<ul>\n<li>Easy to use — install mixin and include in component’s selector;</li>\n<li>Mixins allow for sharing visual identity between components;</li>\n<li>Developers can use mixins in any version without depending on other parts of the page;</li>\n<li>Every component ships with a complete set of styles.</li>\n</ul>\n<p><strong>Cons</strong></p>\n<ul>\n<li>Including mixins introduces duplication of CSS rules between components used on the same page;</li>\n<li>More files — every component brings at least one request for its styles;</li>\n<li>No sharing of CSS — no cache reuse between pages built from different components;</li>\n<li>Clashing of class names within the global namespace.</li>\n</ul>\n<p>In summary, while being very flexible and easy to use, mixins-based approach was not ideal from a performance point of view. Every time when somebody wanted to use a button, input, link etc., they would have to include a mixin for it pulling the entire set of CSS rules to their stylesheet. This resulted in our users downloading unnecessary kilobytes during the first visit while bringing no caching benefit when navigating through other pages which in turn increased rendering times. We knew we could do better.</p>\n<h3>Enter CSS Modules</h3>\n<p>After a lot of brainstorming, a decision was made that the next step should involve Metrum making use of CSS Modules. While the technical aspects and usage were changing as the adoption grew, the main principles stayed the same up to this day. Currently, whenever any developer wants to assemble a new component out of Metrum building blocks, they can install desired packages, compose styles from them and declare used classes in their markup:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-class\">.button</span> {\n    composes: m-button from <span class=\"hljs-string\">&#x27;@metrum/button&#x27;</span>;\n    composes: m-background-color-black from <span class=\"hljs-string\">&#x27;@metrum/color&#x27;</span>;\n}\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./styles.css&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`\n        &lt;button class=&quot;<span class=\"hljs-subst\">${styles.button}</span>&quot;&gt;...&lt;/button&gt;\n    `</span>;\n}\n</code></pre>\n<p>Thanks to the fact that all of our micro frontends run on Node.js, this approach can be used quite easily with the majority of tooling available. The only thing left to do is to collect all of the required Metrum stylesheets during render in our facade server called opbox-web and embed them on the page with the correct order. Ordering requirement is important, because we follow atomic design and more complicated components (molecules, organisms) are built using simpler ones (atoms). Lets see what all of those changes did to our list of tradeoffs:</p>\n<p><strong>Pros</strong></p>\n<ul>\n<li>Still easy to use — install package and compose desired classes in your component;</li>\n<li>Sharing classes means sharing visual traits which was one of our goals;</li>\n<li>Styles for certain module only appear once per page if used in multiple components;</li>\n<li>Each Metrum stylesheet can be cached by the browser separately and reused on different pages;</li>\n<li>Developers can still use packages in any version without depending on other parts of the page.</li>\n</ul>\n<p><strong>Cons</strong></p>\n<ul>\n<li>Additional logic has to be maintained that extracts needed Metrum stylesheets from components and adds them to the page once;</li>\n<li>Above logic has to also take care of sorting so the order of styles is correct and we don’t run into problems with cascade;</li>\n<li>Multiple versions of the same Metrum component may be needed on the page;</li>\n<li>More and more requests have to be made as components transition to the new approach.</li>\n</ul>\n<p>Judging from the upsides the transition was worth it: despite higher maintenance effort we were finally able to share common CSS code between components, the amount of downloaded data as well as render times started decreasing. Unfortunately, after some time we started to see a worrying trend related to the number of embedded stylesheets. Prior to this change, it was roughly equal to the number of components used on the page. Afterwards, with additional Metrum modules, plus the fact that multiple versions of them may be needed, we ended up with as much as around 100 requests for render-blocking CSS.</p>\n<p>Usually, when we bring up the issue of excessive number of requests people respond with “So what? You have HTTP/2, right?” and yes, we do. It’s true that the user agent will reuse existing connections for multiple files but the limit of concurrent streams does exist, latency is still going to affect each one of them and the compression efficiency will be worse especially for those relatively small files like ours. We had to come up with yet another idea for improvement.</p>\n<h3>Let the Bundle Begin</h3>\n<p>As I touched briefly earlier, we have the opbox-web — a place that’s already responsible for extracting, sorting and embedding Metrum dependencies. We figured that instead of adding each of them separately, we could prepare predefined bundles that would serve as replacements. We did as planned and, after deployment on 6th of July 2020, achieved 15% improvement in FCP metric time, which means that our users saw the first render of content faster by almost half a second.</p>\n<p><img src=\"/img/articles/2021-07-29-css-architecture-and-performance-of-micro-frontends/fcp-after-metrum-bundle.png\" alt=\"FCP metric chart before and after deployment of Metrum bundle\" title=\"FCP metric chart before and after deployment of Metrum bundle\"></p>\n<p>Improvement was satisfactory, but it came at a certain cost. From that time on we had to make sure all of the components used on a certain page share the same versions of Metrum modules supported by the bundle and I assure you, it was bothersome to say the least. Monitoring that nobody updated their dependency by accident was one thing (especially that we managed to automate it) but undergoing a process of actually wanting to do this was another. In addition, every time we failed within that area we had to bail and serve every stylesheet separately, preventing incorrect order of CSS and bringing performance to the previous low.</p>\n<p><strong>Pros</strong></p>\n<ul>\n<li>CSS Modules usage stayed the same;</li>\n<li>Fewer requests for critical resources resulted in noticeable improvement in FCP metric.</li>\n</ul>\n<p><strong>Cons</strong></p>\n<ul>\n<li>Extra work is needed to keep Metrum packages versions aligned;</li>\n<li>Updating Metrum dependencies becomes much harder as it requires synchronization between all of the components on a certain page;</li>\n<li>All of the above meant that we only managed to enable this feature on the most popular of routes.</li>\n</ul>\n<p>We knew there was going to be additional effort to maintain this solution but the performance gains outweighed the cost at that time. It took almost a year of tedious work from multiple teams to keep the look and feel of Allegro up to date with newest changes, until we came up with another idea.</p>\n<h3>Just In Time Bundling</h3>\n<p>In the beginning of 2021 another idea started to form. This time we wanted to unlock the agile nature of our Micro Frontends and their deployment. We came to the conclusion that it would be ideal if instead of serving bundles containing a predefined list of components, we could send one composed of just the files that were actually required to render a certain page. Collecting the list of CSS that’s needed was not the problem — we were generating the HEAD section after all — but generating these unique bundles, well that was something different.</p>\n<p>First option we had to verify was the possibility to prepare all of the bundles beforehand so they can be picked and served from CDN. Sadly, taking into account that there are around 500 components, any of which can either be used as a building block of a certain page or not, gives us 2<sup>500</sup> combinations which is way more than we can handle. Even if we optimistically assumed that each stylesheet required around 50ms to generate, it would take us roughly 5x10<sup>141</sup> years to cover everything. Additionally, it would not only be a waste of time and storage (some components have higher possibility to be used than others) but also at least a portion of the work would have to be redone every time a component is updated, what can happen multiple times a day.</p>\n<p>Finally, we went with a different approach by implementing a bundler microservice. Its operating principle can be explained in a few steps:</p>\n<ol>\n<li>When user makes a request for a page, our server collects a list of CSS files that would normally be added to the HEAD section;</li>\n<li>It sends this list of files to our microservice asking for an URL to the corresponding bundle that contains them;</li>\n<li>The microservice checks if it has the bundle in its cache:\n<ol>\n<li>If it does, then bundle URL is immediately returned;</li>\n<li>Otherwise, it also responds right away with empty result, triggering bundle generation in the background;</li>\n</ol>\n</li>\n<li>Based on the response from the microservice, the server either embeds separate CSS files as usual or replaces them with a single bundle.</li>\n</ol>\n<p>This is where we are now – generating only what is actually needed and keeping the duration overhead minimal. A lot of thought and multiple iterations went into making it possible, so I think you can expect a completely separate article about this microservice in the future. Most important thing for us is that the trend of constant improvement for our users continues as confirmed by <a href=\"https://developers.google.com/web/tools/chrome-user-experience-report/\">Chrome UX Report</a>:</p>\n<p><img src=\"/img/articles/2021-07-29-css-architecture-and-performance-of-micro-frontends/fcp-in-crux.png\" alt=\"FCP according to CrUX over last 10 months\" title=\"FCP according to CrUX over last 10 months\"></p>\n<h3>Summary</h3>\n<p>CSS architecture is one of the most important factors influencing performance, what makes ignoring it harder and harder as the page grows. Fortunately, our experience shows that even in higher-scale systems built using micro frontends, it is still possible to improve successfully. By solving problems of existing solutions and experimenting with new ideas we are able to constantly raise the bar of our metrics making browsing Allegro a better experience for our users month by month.</p>\n","excerpt":"<p>It’s been over 5 years since the introduction of the <a href=\"https://blog.allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html\">article describing the ongoing transformation of Allegro’s frontend architecture</a> — an approach that was later formalized by the industry under the name of Micro Frontends. I think that after all this time we can safely say that this direction was correct and remained almost entirely unchanged in relation to the original idea. Still, some of the challenges foreseen in the publication soon became the reality. In this article I would like to focus on the CSS part of the whole adventure to tell you about how we manage consistency and frontend performance across over half a thousand components, and what it took us to get to where we stand today.</p>\n","date":"2021-07-29T00:00:00.000Z","year":"2021","month":"07","day":"29","slug":"2021-07-css-architecture-and-performance-of-micro-frontends","author":[{"author":"mateusz.krzeszowiak","name":"Mateusz Krzeszowiak","bio":"Webperf Team member. Likes to constantly optimize and improve existing solutions. Finds it hard to stop talking about his work and sharing knowledge.","twitter":"krzksz","github":"krzksz"}]},{"data":{"title":"Managing Frontend in the Microservices Architecture","author":["bartosz.galek","bartosz.walacik","pawel.wieladek"],"tags":["frontend","microservices","architecture"]},"content":"<p><a href=\"http://martinfowler.com/articles/microservices.html\">Microservices</a>\nare now the mainstream approach for scalable systems architecture.\nThere is little controversy when we are talking about designing backend services.\nWell-behaved backend microservice should cover one\n<a href=\"http://martinfowler.com/bliki/BoundedContext.html\">BoundedContext</a>\nand communicate over the REST API. <br/>\nThings get complicated when we need to\nuse microservices as building blocks for a frontend solution.\nHow to build a consistent website or a mobile app\nusing tens or sometimes hundreds of microservices?</p>\n<!--more-->\n<p>In this post we describe our current web frontend approach\nand the new one, meant as a small revolution.</p>\n<h2>Doing frontend in the microservices world is tricky</h2>\n<p>Our users don’t care how good we are at dividing our backend into microservices.\nThe question is how good we are at integrating them in a user’s browser.</p>\n<p>Typically, to process one HTTP request sent by a user, we need to collect data from many\nmicroservices.\nFor example, when a user runs a search query on our site, we send him the Listing page.\nThis page collects data from several services: AllegroHeader, Cart, Search, Category Tree, Listing, SEO, Recommendations, etc.\nSome of them provide only data (like Search) and some provide ready-to-serve HTML fragments (like AllegroHeader).\nEach service is maintained by a separate team with various frontend skills.</p>\n<p>Developing modern frontend isn’t easy. Following aspects are involved:</p>\n<ul>\n<li>Classical SOA-style data integration, often done by a dedicated service, called\n<a href=\"http://samnewman.io/patterns/architectural/bff/\">Backend for Frontends</a> or Edge Service.</li>\n<li>Managing frontend dependencies (JS, CSS, etc.) required by various HTML fragments.</li>\n<li>Allowing interactions between HTML fragments served by different services.</li>\n<li>Consistent way of measuring users’ activities (traffic analytics).</li>\n<li>Content customization.</li>\n<li>Providing tools for <a href=\"https://en.wikipedia.org/wiki/A/B_testing\">A/B testing</a>.</li>\n<li>Handling errors and slow responses from backend services.</li>\n<li>There are many frontend devices: web browser, mobile… Smart TV and PlayStation® are waiting in the queue.</li>\n<li>Offering excellent UX to all users (<a href=\"https://en.wikipedia.org/wiki/Multichannel_retailing\">omnichannel</a>).</li>\n</ul>\n<p>The last two things are most important and most challenging.\nThis means that your frontend applications should be consistent, well integrated and <em>smooth</em>.\nEven if they shouldn’t necessarily be monolithic they should <em>look like</em> a monolith.</p>\n<p>Let me give you an example from Spotify.\nYou can listen to the music on a TV set using PS4 Spotify app.\nThen you can switch to Spotify app running on your laptop.\nBoth apps give you a similar <em>look and feel</em>.\nNot bad, but do you know that you can control what PS4 plays\nby clicking on your laptop? It just works. That’s really impressive.</p>\n<p>There are two opposite approaches to modern frontend architecture.</p>\n<ul>\n<li>Monolith approach</li>\n<li>Frankenstein approach</li>\n</ul>\n<p><strong>Monolith approach</strong> is dead simple: one frontend team creates and maintains one frontend application,\nwhich gathers data from backend services using REST API. This approach has one huge advantage, if done right,\nit provides excellent user experience. Main disadvantage is that it doesn’t scale well. In a big company,\nwith many development teams,\nsingle frontend team could become a development bottleneck.</p>\n<p>In <strong>Frankenstein approach</strong> (shared nothing) approach,\nfrontend application is divided into modules and each module is developed independently by separate teams.</p>\n<p>In Web applications modules are HTML page fragments (like AllegroHeader, Cart, Search).\nEach team takes whole responsibility for their product. So a team develops not only backend logic\nbut also provides an endpoint which serves HTML fragment with their <em>piece of frontend</em>.\nThen, HTML page is assembled using some low level server-side includes technology like\n<a href=\"https://en.wikipedia.org/wiki/Edge_Side_Includes\">ESI</a> tags.</p>\n<p>This approach scales well, but the big disadvantage is a lack of consistency on the user side.\nSeams between page fragments become visible, page-level interactions are limited.\nEven in page scope, each page fragment may look, or even worse, behave in a different way.\nPretty much like the Frankenstein monster.</p>\n<p><strong>Between Monolith and Frankenstein</strong> there is a whole spectrum of possible architectures.\nWhat we want to build is the desirable middle ground between these two extremes.</p>\n<p>Next, we describe the current approach at Allegro, which is close to the Frankenstein extreme\nand the new solution, which goes more into the monolith direction.</p>\n<h2>Current approach at Allegro</h2>\n<p>Nowadays at Allegro we have to struggle with the legacy monolithic application\n(written in PHP) and with many new microservices (written mostly in Java).\nEverything is integrated by <a href=\"https://www.varnish-cache.org\">Varnish Cache</a> —\nweb application accelerator (a caching HTTP reverse proxy).</p>\n<p>Varnish and its <a href=\"https://www.w3.org/TR/esi-lang\">ESI LANG</a> features\nallow us to merge a lot of different parts of our platform into one website.\nTherefore any page (or a page fragment) at Allegro\ncan be a separate application.\nFor example, main page is composed in the following way:</p>\n<p><img src=\"/img/articles/2016-01-31-Managing-Frontend-in-the-microservices-architecture/allegro_esi_homepage.jpg\" alt=\"ESI Page Example\" title=\"esi page example\"></p>\n<p>Our Varnish farm also defines and greatly improves our overall performance.\nVarnish servers are exposed to users and they cache all requests for static content.\nWe often say that <em>we are hiding behind Varnish</em> to survive the massive traffic from our users.</p>\n<p>Varnish really hit the bull’s-eye.</p>\n<p>Below, we describe one page fragment, included in each page — the AllegroHeader.</p>\n<p><strong>AllegroHeader</strong> is a service that returns a complete, self-contained page fragment along with\nall needed JS and CSS files — so it can be easily included\nusing the ESI tag at the beginning of any webpage. Under the hood it collects data from a few other services\nlike category service or cart service. It integrates the search box and it’s responsible for top level messages\n(cookies policy warning, under maintenance banner).</p>\n<h3>What has gone wrong?</h3>\n<p>Each page fragment comes with its own set of frontend assets: CSS, JavaScripts, fonts and images.\nAt the page level, it sometimes leads to duplications and version conflicts.\nMany page fragments depend implicitly on assets provided by the AllegroHeader.</p>\n<p>But what if we want to create a page without any AllegroHeader at all?\nOr even worse —\nhow to handle two different versions of <a href=\"https://facebook.github.io/react/\">React</a> within a single page?</p>\n<p>Current approach based on Varnish server-side includes is\nflexible, scalable and easy to develop but unfortunately, it’s hard to maintain.</p>\n<p>Moreover, because every page fragment is a separate web application, it’s really hard to ensure\nconsistent look and feel on the website level.</p>\n<p>We just had to think of a better way…</p>\n<h2>OpBox project — the New Frontend solution</h2>\n<p>So Box is the main concept in our solution. What is Box after all?</p>\n<ul>\n<li>Box is a reusable, high-level frontend component.</li>\n<li>Box is feedable from a REST/JSON data source.</li>\n<li>Box can have slots. In each slot you can put more Boxes.</li>\n<li>Box can be rendered conditionally (for example, depending on A/B test variant).</li>\n<li>Page is assembled from Boxes.</li>\n</ul>\n<p style=\"text-align: center; background-color:#E3E3E3\">\n    <img alt=\"OpBox goals\" style=\"width:75%; padding-top:10px;\" src=\"/img/articles/2016-01-31-Managing-Frontend-in-the-microservices-architecture/opbox-goals.png\" />\n</p>\n<h3>OpBox principles</h3>\n<p>Below, we describe principles of OpBox architecture and functionality.\nMost of them are already implemented and battle-tested. Last two are\nin the design phase.</p>\n<p><strong>Dynamic page creation (CMS-like)</strong><br/>\nPages are created and maintained\nby non-technical users in our Admin application.</p>\n<p><strong>Reusable components</strong><br/>\nEach page is assembled from boxes like AllegroHeader, ShowCase, OfferList, Tabs.\nBoxes are configured to show required content, typically provided via REST API by backend services.</p>\n<p><strong>Separating View from Data Sources</strong><br/>\nBox is a high-level abstraction. It joins two things:</p>\n<ul>\n<li>Frontend design (often referred to as a View).\nConcrete View implementation is called <em>frontend component</em>.\nFor example, our ShowCase box has two frontend implementations: Web and Mobile.</li>\n<li>Data-source (REST service) which feeds data for frontend components.\nOne component can be fed by any data-source as soon as its API matches the Box contract.\nFor example, Offer component knows how to present a nice offer box\nwith offer title, price, image and so on.\nSince Offer component is decoupled from backends by the Box contract abstraction,\nit can show offers from many sources: Recommendations, Listing or Ads services.</li>\n</ul>\n<p><strong>Conditional content</strong><br/>\nBoxes can be rendered conditionally as a way to provide content customization.\nVarious types of conditions are implemented:</p>\n<ul>\n<li>date from/to condition,</li>\n<li>A/B test condition,</li>\n<li>condition based on user profile.</li>\n</ul>\n<p>For example, page editor can prepare two versions of given box,\none for male users and another for female users.\nAt runtime, when page is rendered, user’s gender is identified\nand one of these two boxes is pruned from the boxes tree.</p>\n<p><strong>Consistent traffic analytics</strong><br/>\nBasic traffic analytics is easy to achieve. It’s enough to include a tracking script in\nthe page footer. When a page is opened by a user, the script reports a PageView event.</p>\n<p>What we need is fine-grained data:</p>\n<ul>\n<li>BoxView event — when box is shown in a browser viewport.</li>\n<li>BoxClick event — when users click on a link which navigates them from one box to another\n(for example Recommendation Box can emmit a BoxClick event when users click\non one of the recommended products).</li>\n</ul>\n<p>Once we have this data, we can calculate click-through rate (<a href=\"https://en.wikipedia.org/wiki/Click-through_rate\">CTR</a>).\nfor each box.\nCTR is valuable information for page editors as it helps them to decide\nwhich boxes should be promoted and which should be removed from a page.</p>\n<p><strong>Multi-frontend</strong><br/>\nOne of the OpBox key features is separating page definitions\nfrom frontend renderers.\nPage definition is a JSON document containing the page structure and data (content).\nIt’s up to the renderer how the page is presented to frontend users.</p>\n<p>For now, we have two renderers: Web —\nresponsible for serving HTML and Mobile — responsible for presenting the same content in the Android app.</p>\n<p><strong>One place for integrating backend services through REST API</strong><br/>\nOpBox Core does the whole data integration job\nand sends complete page definitions to frontend renderers.</p>\n<p>It’s a great advantage for frontend developers.\nThey can treat OpBox Core as the single point of contact and the facade to various backend services.</p>\n<p><strong>Future: component Event Bus</strong><br/>\nThere are many use cases when we want Boxes to interact with each other.\nFor example, our Search page lets user search through offers available on Allegro.\nSearch results are shown by the Listing box.\nBelow we have Recommendations box which shows some offers, possibly related with the search query.</p>\n<p>What if we would like to remove an offer from Recommendations box when it\nhappens to be already shown by Listing box?\nOne of the possible solutions is to implement such interactions at the frontend side.</p>\n<p>Desired solution would let rendered Boxes to talk to each other via a\npublish-subscribe message bus, e.g.:</p>\n<p>“Hi, I’m Listing box, I’ve just arrived to a client’s browser to show offers A, C and X.”<br/>\n“Hi, I’m Recommendations box,\nI’m here for a while and I’m showing offers D, E and X. Ouch! Looks like I’m supposed\nto replace X with something different.”</p>\n<p><strong>Future: dependency management</strong><br/>\nEach page is assembled from frontend components developed by different\nteams.\nSince we don’t force frontend developers to use any particular technology,\neach component requires its own dependency set of various kind:\nCSS, JS libraries, fonts and so on.</p>\n<p>Reconciliation of all of those dependency sets is kind of advanced topic and\nto be honest, we don’t have any well-thought-out plan for this yet.</p>\n<h3>How we did it</h3>\n<p>OpBox system is implemented in microservice architecture.\nAs you can see below, it consists of four sub-systems: Core, Web, Admin and Mobile.</p>\n<p style=\"text-align: center; background-color:#E3E3E3\">\n    <img alt=\"OpBox architecture\" style=\"width:75%; padding-top:10px;\" src=\"/img/articles/2016-01-31-Managing-Frontend-in-the-microservices-architecture/opbox-architecture.gif\" />\n</p>\n<h4>OpBox Core</h4>\n<p>Primary responsibility of OpBox Core is serving page definitions for frontend renderers.\nMoreover, Core provides an API to OpBox Admin for page management (creating, editing, publishing).</p>\n<p>Core is the only stateful service in the OpBox family.\nIt stores page definitions in MongoDB and box <em>types</em> in Git (box types are explained below).</p>\n<p>Since Core is responsible for serving page definitions it also manages the page routing\nand the toughest work — fetching data from backend services. That’s the content to be injected into\nBoxes.</p>\n<p>We’ve put a lot of effort into making Core high-performing, fault-tolerant and asynchronous.\nWe’ve chosen Java and Groovy to implement it.\nCore is the only gateway for frontend renderers to our internal backend services.</p>\n<p><strong>Box types</strong> <br/>\nEach Box has a type — it’s the definition that describes data parameters required\nby the Box and also defines a list of named slots. Slot is a placeholder for embedding child boxes.\nWe use (<a href=\"http://json-schema.org/\">JSON Schema</a>) to define parameter types.</p>\n<p>Here is an example of the Showcase Box — along with its type and the type of the data parameter that it uses.</p>\n<p>Showcase Box type:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;slots&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;parameters&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;allegro.box.showcase&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;CUSTOM&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;typeName&quot;</span> <span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;allegro.type.showcasesList&quot;</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;description&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;Showcase box&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;required&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">false</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;nameRequired&quot;</span> <span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>Showcase data parameter type:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;title&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;allegro.showcasesList&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;description&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;showcases list&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;array&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;items&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;description&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;showcase&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;object&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;properties&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;imageUrl&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;string&quot;</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;imageAlt&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;string&quot;</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;linkUrl&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;string&quot;</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>Rendered Showcase Box:</p>\n<p><img src=\"/img/articles/2016-01-31-Managing-Frontend-in-the-microservices-architecture/showcase_box.jpg\" alt=\"rendered showcase box\" title=\"rendered showcase box\"></p>\n<p><strong>Data-source type</strong> is our way to specify underlying backend microservice.\nIt contains: service URL in Service Discovery, input parameters, timeout and caching configuration.\nFor example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;url&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;service://opbox-content/teasers&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;parameters&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;INTEGER&quot;</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;id&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;description&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;article identifiers&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">&quot;required&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;dataType&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;allegro.article.teasers&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;timeoutMillis&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">1500</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;allowCustomParameters&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">false</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;ttlMillis&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">60000</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h4>OpBox Web renderer</h4>\n<p>Web renderer is responsible for handling HTTP requests.\nFrom the Web renderer’s point of view, page rendering process can be decomposed into the following steps:</p>\n<ul>\n<li>HTTP request for a given URL is received.</li>\n<li>OpBox Core is asked for a page definition for a given URL.</li>\n<li>OpBox Core sends a page definition which contains page matadata and the Boxes tree.\nEach Box is filled with data gathered by Core from backend microservices.</li>\n<li>Web renderer traverses the Boxes tree and for each Box:\n<ul>\n<li>Proper component implementation is found in our internal repository (matched by the Box type name).</li>\n<li>Component’s <code>render()</code> function is called with box parameters passed as an argument.</li>\n<li><code>render()</code> result is appended to the HTTP response.</li>\n</ul>\n</li>\n</ul>\n<p>We’ve implemented Web renderer in <a href=\"https://nodejs.org/en/docs/es6/\">ES6</a> on <a href=\"https://nodejs.org/en/\">NodeJS</a> platform.\nComponents are implemented as <a href=\"https://www.npmjs.com/\">NPM</a> packages and they are published to our\ninternal <a href=\"https://www.jfrog.com/artifactory/\">Artifactory</a>.</p>\n<h4>OpBox Mobile renderer library</h4>\n<p>One of our requirements was support for mobile platforms. We’ve created an Android library for rendering pages\nin the same way as Web renderer does but using native mobile code.\nWhen OpBox editor creates a web page he doesn’t have to care about its mobile version.\nHis page should be available both on website and on mobile app.</p>\n<p>This way mobile developers can improve user experience using the same component definitions.\nBy the way — now we can update our pages in your phone instantly ;) (without deploying the new version of the mobile app)</p>\n<h4>OpBox Mobile Adapter</h4>\n<p>We wanted to treat all rendering channels equally so we’re providing one REST API for retrieving page definitions from Core.\nWe’ve created an adapter which transforms the Core API to the mobile friendly version.\nIts main responsibilities are: converting JSON to more concise form, filtering out any mobile-irrelevant data,\nadding deep linking feature and filtering all boxes that are not supported on mobile app.</p>\n<h4>OpBox Admin</h4>\n<p>Simultaneously, we are developing an Admin application for page editors.</p>\n<p>It’s a stateless GUI built on top of the Core REST API.\nIn OpBox Admin our editors create and maintain pages and\nthey manage page routing and publication criteria.</p>\n<p>We’ve implemented OpBox Admin using ES6, NodeJS and <a href=\"https://facebook.github.io/react/\">React</a>.</p>\n<p>Here you can see the sample screen of our Admin GUI:\n<img src=\"/img/articles/2016-01-31-Managing-Frontend-in-the-microservices-architecture/opbox-admin.png\" alt=\"opbox admin\" title=\"Obpox Admin\"></p>\n<h3>Final thoughts</h3>\n<p>Currently some of our marketing campaigns are published with OpBox.\nThe solution has been battle-tested and we are planning to migrate more Allegro pages into OpBox components.\nWe hope to share our OpBox project with the open source community in near future.</p>\n","excerpt":"<p><a href=\"http://martinfowler.com/articles/microservices.html\">Microservices</a>\nare now the mainstream approach for scalable systems architecture.\nThere is little controversy when we are talking about designing backend services.\nWell-behaved backend microservice should cover one\n<a href=\"http://martinfowler.com/bliki/BoundedContext.html\">BoundedContext</a>\nand communicate over the REST API. <br/>\nThings get complicated when we need to\nuse microservices as building blocks for a frontend solution.\nHow to build a consistent website or a mobile app\nusing tens or sometimes hundreds of microservices?</p>\n","date":"2016-03-12T00:00:00.000Z","year":"2016","month":"03","day":"12","slug":"2016-03-Managing-Frontend-in-the-microservices-architecture","author":[{"author":"bartosz.galek","name":"Bartosz Gałek","bio":"Software test engineer with a relevant full stack experience from various companies, who helps achieve better quality results by testing software and sharing knowledge. Testing has been his life since 2011. A real team member, involved not only in all the testing, but also in the final delivery of the product to end users. Besides testing, he loves all kinds of cars and PC games. A big fan of donuts.","linkedin":"paweł-zwierzchowski"},{"author":"bartosz.walacik","name":"Bartosz Walacik","bio":"Software Development Manager with over twenty years of experience in IT and e-commerce. At Allegro he manages the work of 150+ engineers taking care of their continuous substantive development, he is responsible for the technical quality, stability and efficiency of the Allegro platform. He likes simple solutions which gives more possibilities than originally planned :)","twitter":"nigraspl"},{"author":"pawel.wieladek","name":"Paweł Wielądek","bio":"Doer. Microsoft MVP. Master of Science. Speaker and blogger. VP at devwarsztaty.pl. CxO of dotnetomaniak.pl. Don't Stapp me now, please!","twitter":"ptrstpp950","linkedin":"piotrstapp"}]}]