<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<title>gotomi.info</title>
<meta name="description" content="gotomi.info  - personal page">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&amp;family=Source+Sans+Pro&amp;display=swap" rel="stylesheet"> 
<link rel="stylesheet" href="/style/global.css">



</head><body id="top">

<link rel="stylesheet" href="../../assets/a11y-dark.e19cdc70.css"><link rel="stylesheet" href="../../assets/index.1d126219.css">

    <header class="astro-6WYRBI6L">
<a href="/#top" class="astro-6WYRBI6L"><div class="logo astro-6WYRBI6L">gotomi.info</div></a>
<nav class="astro-6WYRBI6L">
<ul class="astro-6WYRBI6L">
<!-- <li><a href="/">about</a></li> -->
<!-- <li><a href="/">home</a></li>
<li><a href="/blog">blog</a></li>
<li><a href="/after">after work</a></li> -->

</ul> 
</nav>
</header>


    <main>
      <div class="blog-post">
 <time class="entry-date" datetime="2021-07-29T00:00:00.000Z">Jul 29, 2021</time>
  <h2 class="section-title">CSS Architecture and Performance in Micro Frontends</h2>
  <ul class="astro-VVMLGW7B">
  <li class="astro-VVMLGW7B"><a href="/blog/author/mateusz.krzeszowiak" class="astro-VVMLGW7B"><img src="/img/authors/mateusz.krzeszowiak.jpg" alt="mateusz.krzeszowiak" class="astro-VVMLGW7B">Mateusz Krzeszowiak</a></li>
</ul>


  <article class="blog-post-content">
      <p>It’s been over 5 years since the introduction of the <a href="https://blog.allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html">article describing the ongoing transformation of Allegro’s frontend architecture</a> — an approach that was later formalized by the industry under the name of Micro Frontends. I think that after all this time we can safely say that this direction was correct and remained almost entirely unchanged in relation to the original idea. Still, some of the challenges foreseen in the publication soon became the reality. In this article I would like to focus on the CSS part of the whole adventure to tell you about how we manage consistency and frontend performance across over half a thousand components, and what it took us to get to where we stand today.</p>
<!--more-->
<h3>New Approach — New Challenges</h3>
<p>Handling all the dependencies, libraries and visual compatibility when the entire website resides in a single repository is a challenge by itself. The level of difficulty increases even more, when there are hundreds of said repositories, each managed by a different team and tooling. When in such situation, one of the things that quickly become apparent is the need for some kind of guidelines around the look of various aspects of components being developed like color scheme, spacing, fonts etc. — those are exactly the reasons why the Metrum Design System came to life.</p>
<p><img src="/img/articles/2021-07-29-css-architecture-and-performance-of-micro-frontends/metrum-design-system.jpg" alt="Metrum Design System" title="Metrum Design System"></p>
<p>In its initial form — apart from visual examples and design resources — Metrum was providing reusable PostCSS mixins that every developer could install via separate npm packages and include in the component they were working on.</p>
<pre class="hljs"><code><span class="hljs-keyword">@import</span> <span class="hljs-string">'node_modules/@metrum/button/css/mixins.css'</span>;

<span class="hljs-selector-class">.button</span> {
    <span class="hljs-keyword">@mixin</span> m-button;
    <span class="hljs-attribute">background-color</span>: black;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>If we try to evaluate that approach we could come up with following pros and cons:</p>
<p><strong>Pros</strong></p>
<ul>
<li>Easy to use — install mixin and include in component’s selector;</li>
<li>Mixins allow for sharing visual identity between components;</li>
<li>Developers can use mixins in any version without depending on other parts of the page;</li>
<li>Every component ships with a complete set of styles.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Including mixins introduces duplication of CSS rules between components used on the same page;</li>
<li>More files — every component brings at least one request for its styles;</li>
<li>No sharing of CSS — no cache reuse between pages built from different components;</li>
<li>Clashing of class names within the global namespace.</li>
</ul>
<p>In summary, while being very flexible and easy to use, mixins-based approach was not ideal from a performance point of view. Every time when somebody wanted to use a button, input, link etc., they would have to include a mixin for it pulling the entire set of CSS rules to their stylesheet. This resulted in our users downloading unnecessary kilobytes during the first visit while bringing no caching benefit when navigating through other pages which in turn increased rendering times. We knew we could do better.</p>
<h3>Enter CSS Modules</h3>
<p>After a lot of brainstorming, a decision was made that the next step should involve Metrum making use of CSS Modules. While the technical aspects and usage were changing as the adoption grew, the main principles stayed the same up to this day. Currently, whenever any developer wants to assemble a new component out of Metrum building blocks, they can install desired packages, compose styles from them and declare used classes in their markup:</p>
<pre class="hljs"><code><span class="hljs-selector-class">.button</span> {
    composes: m-button from <span class="hljs-string">'@metrum/button'</span>;
    composes: m-background-color-black from <span class="hljs-string">'@metrum/color'</span>;
}
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./styles.css'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
        &lt;button class="<span class="hljs-subst">${styles.button}</span>"&gt;...&lt;/button&gt;
    `</span>;
}
</code></pre>
<p>Thanks to the fact that all of our micro frontends run on Node.js, this approach can be used quite easily with the majority of tooling available. The only thing left to do is to collect all of the required Metrum stylesheets during render in our facade server called opbox-web and embed them on the page with the correct order. Ordering requirement is important, because we follow atomic design and more complicated components (molecules, organisms) are built using simpler ones (atoms). Lets see what all of those changes did to our list of tradeoffs:</p>
<p><strong>Pros</strong></p>
<ul>
<li>Still easy to use — install package and compose desired classes in your component;</li>
<li>Sharing classes means sharing visual traits which was one of our goals;</li>
<li>Styles for certain module only appear once per page if used in multiple components;</li>
<li>Each Metrum stylesheet can be cached by the browser separately and reused on different pages;</li>
<li>Developers can still use packages in any version without depending on other parts of the page.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Additional logic has to be maintained that extracts needed Metrum stylesheets from components and adds them to the page once;</li>
<li>Above logic has to also take care of sorting so the order of styles is correct and we don’t run into problems with cascade;</li>
<li>Multiple versions of the same Metrum component may be needed on the page;</li>
<li>More and more requests have to be made as components transition to the new approach.</li>
</ul>
<p>Judging from the upsides the transition was worth it: despite higher maintenance effort we were finally able to share common CSS code between components, the amount of downloaded data as well as render times started decreasing. Unfortunately, after some time we started to see a worrying trend related to the number of embedded stylesheets. Prior to this change, it was roughly equal to the number of components used on the page. Afterwards, with additional Metrum modules, plus the fact that multiple versions of them may be needed, we ended up with as much as around 100 requests for render-blocking CSS.</p>
<p>Usually, when we bring up the issue of excessive number of requests people respond with “So what? You have HTTP/2, right?” and yes, we do. It’s true that the user agent will reuse existing connections for multiple files but the limit of concurrent streams does exist, latency is still going to affect each one of them and the compression efficiency will be worse especially for those relatively small files like ours. We had to come up with yet another idea for improvement.</p>
<h3>Let the Bundle Begin</h3>
<p>As I touched briefly earlier, we have the opbox-web — a place that’s already responsible for extracting, sorting and embedding Metrum dependencies. We figured that instead of adding each of them separately, we could prepare predefined bundles that would serve as replacements. We did as planned and, after deployment on 6th of July 2020, achieved 15% improvement in FCP metric time, which means that our users saw the first render of content faster by almost half a second.</p>
<p><img src="/img/articles/2021-07-29-css-architecture-and-performance-of-micro-frontends/fcp-after-metrum-bundle.png" alt="FCP metric chart before and after deployment of Metrum bundle" title="FCP metric chart before and after deployment of Metrum bundle"></p>
<p>Improvement was satisfactory, but it came at a certain cost. From that time on we had to make sure all of the components used on a certain page share the same versions of Metrum modules supported by the bundle and I assure you, it was bothersome to say the least. Monitoring that nobody updated their dependency by accident was one thing (especially that we managed to automate it) but undergoing a process of actually wanting to do this was another. In addition, every time we failed within that area we had to bail and serve every stylesheet separately, preventing incorrect order of CSS and bringing performance to the previous low.</p>
<p><strong>Pros</strong></p>
<ul>
<li>CSS Modules usage stayed the same;</li>
<li>Fewer requests for critical resources resulted in noticeable improvement in FCP metric.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Extra work is needed to keep Metrum packages versions aligned;</li>
<li>Updating Metrum dependencies becomes much harder as it requires synchronization between all of the components on a certain page;</li>
<li>All of the above meant that we only managed to enable this feature on the most popular of routes.</li>
</ul>
<p>We knew there was going to be additional effort to maintain this solution but the performance gains outweighed the cost at that time. It took almost a year of tedious work from multiple teams to keep the look and feel of Allegro up to date with newest changes, until we came up with another idea.</p>
<h3>Just In Time Bundling</h3>
<p>In the beginning of 2021 another idea started to form. This time we wanted to unlock the agile nature of our Micro Frontends and their deployment. We came to the conclusion that it would be ideal if instead of serving bundles containing a predefined list of components, we could send one composed of just the files that were actually required to render a certain page. Collecting the list of CSS that’s needed was not the problem — we were generating the HEAD section after all — but generating these unique bundles, well that was something different.</p>
<p>First option we had to verify was the possibility to prepare all of the bundles beforehand so they can be picked and served from CDN. Sadly, taking into account that there are around 500 components, any of which can either be used as a building block of a certain page or not, gives us 2<sup>500</sup> combinations which is way more than we can handle. Even if we optimistically assumed that each stylesheet required around 50ms to generate, it would take us roughly 5x10<sup>141</sup> years to cover everything. Additionally, it would not only be a waste of time and storage (some components have higher possibility to be used than others) but also at least a portion of the work would have to be redone every time a component is updated, what can happen multiple times a day.</p>
<p>Finally, we went with a different approach by implementing a bundler microservice. Its operating principle can be explained in a few steps:</p>
<ol>
<li>When user makes a request for a page, our server collects a list of CSS files that would normally be added to the HEAD section;</li>
<li>It sends this list of files to our microservice asking for an URL to the corresponding bundle that contains them;</li>
<li>The microservice checks if it has the bundle in its cache:
<ol>
<li>If it does, then bundle URL is immediately returned;</li>
<li>Otherwise, it also responds right away with empty result, triggering bundle generation in the background;</li>
</ol>
</li>
<li>Based on the response from the microservice, the server either embeds separate CSS files as usual or replaces them with a single bundle.</li>
</ol>
<p>This is where we are now – generating only what is actually needed and keeping the duration overhead minimal. A lot of thought and multiple iterations went into making it possible, so I think you can expect a completely separate article about this microservice in the future. Most important thing for us is that the trend of constant improvement for our users continues as confirmed by <a href="https://developers.google.com/web/tools/chrome-user-experience-report/">Chrome UX Report</a>:</p>
<p><img src="/img/articles/2021-07-29-css-architecture-and-performance-of-micro-frontends/fcp-in-crux.png" alt="FCP according to CrUX over last 10 months" title="FCP according to CrUX over last 10 months"></p>
<h3>Summary</h3>
<p>CSS architecture is one of the most important factors influencing performance, what makes ignoring it harder and harder as the page grows. Fortunately, our experience shows that even in higher-scale systems built using micro frontends, it is still possible to improve successfully. By solving problems of existing solutions and experimenting with new ideas we are able to constantly raise the bar of our metrics making browsing Allegro a better experience for our users month by month.</p>

      <ul class="astro-IZKKI55I">
  <li class="astro-IZKKI55I"><a href="/blog/tag/tech" class="astro-IZKKI55I">tech</a></li><li class="astro-IZKKI55I"><a href="/blog/tag/webperf" class="astro-IZKKI55I">webperf</a></li><li class="astro-IZKKI55I"><a href="/blog/tag/frontend" class="astro-IZKKI55I">frontend</a></li><li class="astro-IZKKI55I"><a href="/blog/tag/performance" class="astro-IZKKI55I">performance</a></li><li class="astro-IZKKI55I"><a href="/blog/tag/perfmatters" class="astro-IZKKI55I">perfmatters</a></li><li class="astro-IZKKI55I"><a href="/blog/tag/css" class="astro-IZKKI55I">css</a></li>
</ul>


  </article>
  
<div class="post-author astro-ZZFAM35N">
    <img src="/img/authors/mateusz.krzeszowiak.jpg" alt="Mateusz Krzeszowiak" class="avatar astro-ZZFAM35N">
    <div class="astro-ZZFAM35N">
    <h3 class="astro-ZZFAM35N"> Mateusz Krzeszowiak  <a class="username" href="https://twitter.com/krzksz">
                <span class="social"><img src="/img/social/twitter.svg" alt="twitter"></span>
            </a><a class="username" href="https://github.com/krzksz">
                <span class="social"><img src="/img/social/github.svg" alt="github"></span>
            </a></h3>
    <p class="astro-ZZFAM35N">Webperf Team member. Likes to constantly optimize and improve existing solutions. Finds it hard to stop talking about his work and sharing knowledge.</p>
    </div>
</div>


  </div>
    </main>
    <footer>© 2022 Tomasz Gospodarczyk | designed in the browser</footer>
</body></html>